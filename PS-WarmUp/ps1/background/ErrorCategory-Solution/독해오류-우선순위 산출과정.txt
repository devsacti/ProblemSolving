만약 거리가 같은 적이 2명 이상일 경우 y 좌표가 작은 적에게 우선 이동한다. 거리가 같고, y 좌표가 동일한 적이 2명 이상일 경우 x 좌표가 작은 적을 향해 이동한다.

나는 여기서 최대한 간단한 코딩을 상상하다보니, 이 3가지 독립변수를 통해 새로운 값을 정의하기로 생각

그래서 아래와같이 코딩

def getPriority(dist,y,x):
    return dist+y+x

중략

            if(graph[nowR][nowC]<k):
                info_map[nowR][nowC]=nowCost
                # 우선순위의 독립변수는 거리 그 다음 y(=r) 그 다음 x(=c)
                # <WRONG>그리고 3가지 모두 양의 정수라 이들의 합으로 오름차순 우선순위 정의가능
                # 우선 nowCost만 비교,
                # 그런데도 같으며 '그 다음에' nowCost+nowR
                # 그런데도 같으면 '그 다음에' nowCost+nowR+nowC
                heapq.heappush(pq,(getPriority(nowCost,nowR,nowC),nowR,nowC))

하지만 주석대로
내가 구한 값은 최종상황에서의 판단이었음

그리고 힙에 다중정렬이 없기에,
heapq에서 리스트+다중정렬로 선회

문제를 곡해하진 않고, 코드화 중 내 머릿속 특수 상황에만 맞는 코드를 구현해버림.
다시 문제를 읽어서 내 머릿속 상황을 확장시켜야


전체 코드

